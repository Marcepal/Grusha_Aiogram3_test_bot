from typing import Union, Dict, Any

from aiogram.filters import BaseFilter
from aiogram.types import Message
class HasUsernamesFilter(BaseFilter):
# -> Union[bool, Dict[str, Any]]:- Этот метод будет возвращать либо булевое значение (False),
    # либо словарь, содержащий найденные юзернеймы.
    async def call(self, message: Message) -> Union[bool, Dict[str, Any]]:
        # Если entities вообще нет, вернётся None,
        # в этом случае считаем, что это пустой список.
        entities = message.entities or []
        # Проверяем любые юзернеймы и извлекаем их из текста
        # методом extract_from(). Подробнее см. главу
        # про работу с сообщениями.
        found_usernames = [
            item.extract_from(message.text) for item in entities
            if item.type == "mention"# Проверяем, является ли элемент типа "mention"-ссылки на пользователей (например, @username).
        ]
        # Если юзернеймы есть, то "проталкиваем" их в хэндлер
        # по имени "usernames". Мы возвращаем словарь,
        # где ключом является строка "usernames", а значением —
        # список найденных юзернеймов.
        if len(found_usernames) > 0:
            return {"usernames": found_usernames}
        # Если не нашли ни одного юзернейма, вернём False,
        # что указывает на отсутствие упоминаний в сообщении.
        return False

# **Entities** (сущности) в контексте сообщений, особенно в мессенджерах и
# социальных сетях, представляют собой структурированные данные,
# которые содержат информацию о различных элементах текста.
# Например, в сообщении могут быть упоминания пользователей, хэштеги, ссылки и так далее.
#
# В случае мессенджеров, таких как Telegram, entities могут включать:
#
# - **Упоминания** (mentions): ссылки на пользователей
# (например, @username).
# - **Хэштеги**: слова или фразы, начинающиеся с символа #
# (например, #topic).
# - **Ссылки**: URL-адреса.
# - **Коды**: например, выделенные фрагменты текста.
#
# Каждый элемент entities обычно содержит информацию о типе сущности
# (например, "mention", "hashtag" и т. д.),
# а также позицию (индексы) в тексте сообщения.


# Метод extract_from — это функция, которая, вероятно, используется
# для извлечения конкретной информации из текста сообщения,
# основываясь на сущности.
# Например, если у нас есть сущность типа "mention", метод может извлечь
# имя пользователя из текста сообщения.



# отличие фильтров от мидлварей:
#
# фильтры решают куда запихнуть update от пользователя
#
# внешние мидлвари решают допускать ли update вообще(до фильтров,хендлеров)

# внутрение мидлвари уже срабатывают после фильтров




# В целом мидлвари нужны для того, чтобы прокинуть какие-то данные вместе с апдейтом или сделать какую-то дополнительную работу, которая не обязательно относиться к апдейту.
#
# Можно это "что-то" делать напрямую в обработчике и это нормальный вариант, но если тебе нужно это "что-то" делать во всех обработчиках, то это выходит трудозатратно и к тому же очень много дублирующегося кода. Поэтому можно добавить мидлварь, которую ты подключишь к роутеру и в ней будешь получать/делать то что нужно и прокидывать вместе с апдейтом - работает точно также, только удобнее и меньше кода.
#
# И у нас как оно устроено
#
# внешняя мидлварь
#               ⬇️
#            фильтр
#               ⬇️
# внутренняя мидлварь
#               ⬇️
#      обработчик
#
# Если ты повесишь мидлварь как внешную, то она будет срабатывать каждый раз как приходит апдейт, а если как внутренную, то только если апдейт прошел фильтр.
#
# Например, у тебя есть мидлварь, которая делает какие-то запросы к базе за данными пользователя, но только если он написал в группе (проверяешь фильтром). Что-то тянуть из базы есть смысл только тогда, когда эти данные будут использоваться, а то ты данные из базы заберешь, а человек написал в личку боту и фильтр сообщение не пропустит и в итоге делаешь лишную работу. А если у тебя популярный бот? Будешь делать кучу запросов просто-так. В таком случае лучше ставить такую мидлварь как внутренную.
#
# Есть другой пример, например ты решил настроить аналитику в боте и записываешь какие-то данные из каждого апдейта который приходит, что-то логируешь для себя. В таком случае, если ты поставишь ее как внутренную, то потеряешь часть апдейтов, которые через фильтр не прошли и такие штуки лучше подключать как внешние мидлвари.
